var LineChart = {
    defaultConfig: {
        containerClass: "line-chart",
        // margin.top is for axis/labels only, not for title
        margin: {top: 30, right: 30, bottom: 30, left: 60},
        title: undefined,
        // Add a titleHeight property for spacing above the chart
        titleHeight: 40
    },
    chart: function () {
        var a = Object.create(LineChart.defaultConfig);
        function chart(selection) {
            a.w = window.innerWidth;
            a.h = window.innerHeight;

            selection.each(function (input) {
                var data = (input && input.data) ? input.data : (Array.isArray(input) ? input : []);
                var statLine = input && input.statLine ? input.statLine : undefined;
                var title = input && input.title ? input.title : a.title;
                var mainLineColor = (input && input.lineColor) ? input.lineColor : "#000";

                if (!Array.isArray(data)) data = [];
                data = data.filter(d => d && d.x !== undefined && d.y !== undefined);

                var margin = a.margin,
                    // Subtract titleHeight from available height for the chart area
                    width = a.w - margin.left - margin.right,
                    height = a.h - margin.top - margin.bottom - (a.title ? a.titleHeight : 0);

                d3.select(this).selectAll("*").remove();

                // Draw the title above the chart area, outside the main <g>
                if (title) {
                    d3.select(this)
                        .append("text")
                        .attr("class", "chart-title")
                        .attr("x", a.w / 2)
                        .attr("y", a.titleHeight / 2 + 5)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .text(title);
                }

                // === CATEGORY COLOR BAR (above chart area, width according to x positions) ===
                // Only draw if there are at least 2 points and category color info
                if (data.length > 1 && data[0].category !== undefined) {
                    let barHeight = 10;
                    let barY = (a.title ? a.titleHeight : 0) + 5;
                    let margin = a.margin;
                    let width = a.w - margin.left - margin.right;

                    // Compute x scale for bar (same as chart)
                    let xVals = data.map(d => d.x);
                    let xDomain = d3.extent(xVals);
                    let xBar = d3.scaleLinear()
                        .domain(xDomain)
                        .range([margin.left, a.w - margin.right]);

                    let svgBar = d3.select(this);

                    for (let i = 0; i < data.length - 1; ++i) {
                        let p0 = data[i];
                        let p1 = data[i + 1];
                        // Use color from category[0] if category is an array, else fallback
                        let color = Array.isArray(p0.category) ? p0.category[0] : p0.category;
                        svgBar.append("rect")
                            .attr("x", xBar(p0.x))
                            .attr("y", barY)
                            .attr("width", xBar(p1.x) - xBar(p0.x))
                            .attr("height", barHeight)
                            .attr("fill", color || "#ccc")
                            .attr("stroke", "none");
                    }
                    // Optionally, add a rect for the last point if it is isolated (no next point)
                    if (data.length === 2) {
                        let pLast = data[1];
                        let pPrev = data[0];
                        let color = Array.isArray(pLast.category) ? pLast.category[0] : pLast.category;
                        let lastWidth = Math.max(2, xBar(pLast.x) - xBar(pPrev.x));
                        svgBar.append("rect")
                            .attr("x", xBar(pLast.x))
                            .attr("y", barY)
                            .attr("width", lastWidth)
                            .attr("height", barHeight)
                            .attr("fill", color || "#ccc")
                            .attr("stroke", "none");
                    }
                }
                // === END CATEGORY COLOR BAR ===

                if (!data || data.length === 0) {
                    d3.select(this)
                        .append("text")
                        .attr("class", "no-data-message")
                        .attr("x", a.w / 2)
                        .attr("y", a.h / 2)
                        .attr("text-anchor", "middle")
                        .text("No data available");
                    return;
                }

                // Shift the chart area down by titleHeight
                var svg = d3.select(this)
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("viewBox", `0 0 ${a.w} ${a.h}`)
                    .classed("svg-content", true)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top + (a.title ? a.titleHeight : 0)})`);

                let xVals = data.map(d => d.x);
                let yVals = data.map(d => d.y);
                if (statLine) {
                    if (statLine.start_x !== undefined && statLine.end_x !== undefined)
                        xVals.push(+statLine.start_x, +statLine.end_x);
                    if (statLine.start_y !== undefined && statLine.end_y !== undefined)
                        yVals.push(+statLine.start_y, +statLine.end_y);
                }
                var xDomain = d3.extent(xVals);
                var yDomain = d3.extent(yVals);

                var x = d3.scaleLinear()
                    .domain(xDomain)
                    .range([0, width]);
                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x));

                var y = d3.scaleLinear()
                    .domain(yDomain)
                    .range([height, 0]);
                svg.append("g")
                    .call(d3.axisLeft(y));

                for (let i = 0; i < data.length - 1; ++i) {
                    let p0 = data[i];
                    let p1 = data[i + 1];
                    svg.append("line")
                        .attr("x1", x(p0.x))
                        .attr("y1", y(p0.y))
                        .attr("x2", x(p1.x))
                        .attr("y2", y(p1.y))
                        .attr("stroke", mainLineColor)
                        .attr("stroke-width", 2)
                        .attr("fill", "none");
                }

                if (statLine && typeof statLine === "object" &&
                    statLine.start_x !== undefined && statLine.start_y !== undefined &&
                    statLine.end_x !== undefined && statLine.end_y !== undefined) {
                    svg.append("line")
                        .attr("x1", x(+statLine.start_x))
                        .attr("y1", y(+statLine.start_y))
                        .attr("x2", x(+statLine.end_x))
                        .attr("y2", y(+statLine.end_y))
                        .attr("stroke", statLine.color || "#d62728")
                        .attr("stroke-width", 3)
                        .attr("stroke-dasharray", "8,4")
                        .attr("fill", "none")
                        .attr("class", "stat-line");

                    let pointSize = statLine.pointSize ? +statLine.pointSize : 6;
                    let color = statLine.color || "#d62728";
                    let x0 = x(+statLine.start_x), y0 = y(+statLine.start_y);
                    let x1_ = x(+statLine.end_x), y1_ = y(+statLine.end_y);

                    svg.append("circle")
                        .attr("cx", x0)
                        .attr("cy", y0)
                        .attr("r", pointSize)
                        .attr("fill", color)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 1.5)
                        .attr("class", "stat-bundle-dot");

                    svg.append("circle")
                        .attr("cx", x1_)
                        .attr("cy", y1_)
                        .attr("r", pointSize)
                        .attr("fill", color)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 1.5)
                        .attr("class", "stat-bundle-dot");
                }

                let minX = d3.min(xVals, d => x(d)), maxX = d3.max(xVals, d => x(d));
                let minY = d3.min(yVals, d => y(d)), maxY = d3.max(yVals, d => y(d));
                const legendWidth = 200, legendHeight = statLine ? 60 : 28, pad = 10;
                const positions = [
                    [pad, pad],
                    [width - legendWidth - pad, pad],
                    [pad, height - legendHeight - pad],
                    [width - legendWidth - pad, height - legendHeight - pad]
                ];
                function overlaps(x0, y0) {
                    const box = {x1: x0, y1: y0, x2: x0 + legendWidth, y2: y0 + legendHeight};
                    const dataBox = {x1: minX - 10, y1: minY - 10, x2: maxX + 10, y2: maxY + 10};
                    return !(box.x2 < dataBox.x1 || box.x1 > dataBox.x2 || box.y2 < dataBox.y1 || box.y1 > dataBox.y2);
                }
                let legendPos = positions.find(pos => !overlaps(pos[0], pos[1])) || positions[1];

                var legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${legendPos[0]},${legendPos[1]})`);

                if (data.length > 0) {
                    legend.append("line")
                        .attr("x1", 0).attr("y1", 0).attr("x2", 30).attr("y2", 0)
                        .attr("stroke", mainLineColor)
                        .attr("stroke-width", 2);
                    legend.append("text")
                        .attr("x", 40).attr("y", 5)
                        .text("Main Line")
                        .attr("alignment-baseline", "middle");
                }
                if (statLine && statLine.start_x !== undefined && statLine.start_y !== undefined &&
                    statLine.end_x !== undefined && statLine.end_y !== undefined) {
                    legend.append("line")
                        .attr("x1", 0).attr("y1", 20).attr("x2", 30).attr("y2", 20)
                        .attr("stroke", statLine.color || "#d62728")
                        .attr("stroke-width", 3)
                        .attr("stroke-dasharray", "8,4");
                    let pointSize = statLine.pointSize ? +statLine.pointSize : 6;
                    let color = statLine.color || "#d62728";
                    let nStart = parseInt(statLine.n_start) || 0;
                    let nEnd = parseInt(statLine.n_end) || 0;
                    legend.append("circle")
                        .attr("cx", 15).attr("cy", 40)
                        .attr("r", pointSize)
                        .attr("fill", color)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 1.5);
                    legend.append("text")
                        .attr("x", 30).attr("y", 44)
                        .text(`Start: ${nStart} points`)
                        .attr("alignment-baseline", "middle");
                    legend.append("circle")
                        .attr("cx", 15).attr("cy", 58)
                        .attr("r", pointSize)
                        .attr("fill", color)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 1.5);
                    legend.append("text")
                        .attr("x", 30).attr("y", 62)
                        .text(`End: ${nEnd} points`)
                        .attr("alignment-baseline", "middle");
                    legend.append("text")
                        .attr("x", 40).attr("y", 25)
                        .text(statLine.label || "Statistical Line")
                        .attr("alignment-baseline", "middle");
                }
            });
        }
        chart.config = function (b) {
            if (!arguments.length) return a;
            Object.entries(b || {}).forEach(function (kv) { a[kv[0]] = kv[1]; });
            return chart;
        };
        return chart;
    },
    draw: function (a, b, c) {
        var d = LineChart.chart().config(c),
            e = d.config();
        d3.select(a).select("svg").remove();
        d3.select(a)
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${window.innerWidth} ${window.innerHeight}`)
            .classed("svg-content", true)
            .datum(b)
            .call(d);
    }
};

if (typeof window !== "undefined") {
    if (!window._lineChartResizeHandler) {
        window._lineChartResizeHandler = function() {
            if (window.chart && window._lastChartData) {
                d3.select("div#container").select("svg").remove();
                d3.select("div#container").selectAll(".no-data-message").remove();
                var d = window._lastChartData;
                var data = d && d.data ? d.data : [];
                if (!Array.isArray(data) || data.length === 0) {
                    d3.select("div#container")
                        .append("div")
                        .attr("class", "no-data-message")
                        .text("No data available");
                    return;
                }
                d3.select("div#container")
                    .append("svg")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("viewBox", `0 0 ${window.innerWidth} ${window.innerHeight}`)
                    .classed("svg-content", true)
                    .datum(window._lastChartData)
                    .call(window.chart);
            }
        };
        window.addEventListener("resize", window._lineChartResizeHandler);
    }
}