var LineChart = {
    defaultConfig: {
        containerClass: "line-chart",
        margin: {top: 10, right: 30, bottom: 30, left: 60}
    },
    chart: function () {
        var a = Object.create(LineChart.defaultConfig);
        function chart(selection) {
            a.w = window.innerWidth;
            a.h = window.innerHeight;

            selection.each(function (input) {
                // Support new structure: {data: [...], statLine: {...}}
                var data = input.data || input;
                var statLine = input.statLine;

                if (Array.isArray(data) && Array.isArray(data[0])) data = data[0];

                var margin = a.margin,
                    width = a.w - margin.left - margin.right,
                    height = a.h - margin.top - margin.bottom;

                d3.select(this).selectAll("*").remove();

                var svg = d3.select(this)
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("viewBox", `0 0 ${a.w} ${a.h}`)
                    .classed("svg-content", true)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                var x = d3.scaleLinear()
                    .domain(d3.extent(data, function(d) { return d.x; }))
                    .range([0, width]);
                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x));

                var y = d3.scaleLinear()
                    .domain([0, d3.max(data, function(d) { return +d.y; })])
                    .range([height, 0]);
                svg.append("g")
                    .call(d3.axisLeft(y));

                // Draw line segments, each colored by the category color of the starting point
                for (let i = 0; i < data.length - 1; ++i) {
                    let p0 = data[i];
                    let p1 = data[i + 1];
                    let color = (p0.category && Array.isArray(p0.category)) ? p0.category[0] : "#000";
                    svg.append("line")
                        .attr("x1", x(p0.x))
                        .attr("y1", y(p0.y))
                        .attr("x2", x(p1.x))
                        .attr("y2", y(p1.y))
                        .attr("stroke", color)
                        .attr("stroke-width", 2)
                        .attr("fill", "none");
                }

                // --- Statistical line ---
                if (statLine && typeof statLine === "object") {
                    svg.append("line")
                        .attr("x1", x(+statLine.start_x))
                        .attr("y1", y(+statLine.start_y))
                        .attr("x2", x(+statLine.end_x))
                        .attr("y2", y(+statLine.end_y))
                        .attr("stroke", statLine.color || "#d62728")
                        .attr("stroke-width", 3)
                        .attr("stroke-dasharray", "8,4")
                        .attr("fill", "none")
                        .attr("class", "stat-line");
                }

                // --- Legend ---
                var legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${width - 180},${20})`);

                // Main line legend (use first category color)
                if (data.length > 0) {
                    legend.append("line")
                        .attr("x1", 0).attr("y1", 0).attr("x2", 30).attr("y2", 0)
                        .attr("stroke", (data[0].category && Array.isArray(data[0].category)) ? data[0].category[0] : "#000")
                        .attr("stroke-width", 2);
                    legend.append("text")
                        .attr("x", 40).attr("y", 5)
                        .text("Main Line")
                        .attr("alignment-baseline", "middle");
                }
                // Stat line legend
                if (statLine) {
                    legend.append("line")
                        .attr("x1", 0).attr("y1", 20).attr("x2", 30).attr("y2", 20)
                        .attr("stroke", statLine.color || "#d62728")
                        .attr("stroke-width", 3)
                        .attr("stroke-dasharray", "8,4");
                    legend.append("text")
                        .attr("x", 40).attr("y", 25)
                        .text(statLine.label || "Statistical Line")
                        .attr("alignment-baseline", "middle");
                }
            });
        }
        chart.config = function (b) {
            if (!arguments.length) return a;
            Object.entries(b || {}).forEach(function (kv) { a[kv[0]] = kv[1]; });
            return chart;
        };
        return chart;
    },
    draw: function (a, b, c) {
        var d = LineChart.chart().config(c),
            e = d.config();
        d3.select(a).select("svg").remove();
        d3.select(a)
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${window.innerWidth} ${window.innerHeight}`)
            .classed("svg-content", true)
            .datum(b)
            .call(d);
    }
};

// --- Responsive resize support ---
if (typeof window !== "undefined") {
    if (!window._lineChartResizeHandler) {
        window._lineChartResizeHandler = function() {
            if (window.chart && window._lastChartData) {
                d3.select("div#container").select("svg").remove();
                d3.select("div#container")
                    .append("svg")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("viewBox", `0 0 ${window.innerWidth} ${window.innerHeight}`)
                    .classed("svg-content", true)
                    .datum(window._lastChartData)
                    .call(window.chart);
            }
        };
        window.addEventListener("resize", window._lineChartResizeHandler);
    }
}